\hypertarget{Client_2Cache_8c}{\section{Riferimenti per il file Client/\+Cache.c}
\label{Client_2Cache_8c}\index{Client/\+Cache.\+c@{Client/\+Cache.\+c}}
}
{\ttfamily \#include $<$stdio.\+h$>$}\\*
{\ttfamily \#include $<$string.\+h$>$}\\*
{\ttfamily \#include $<$stdlib.\+h$>$}\\*
{\ttfamily \#include $<$unistd.\+h$>$}\\*
{\ttfamily \#include $<$limits.\+h$>$}\\*
{\ttfamily \#include \char`\"{}inc/\+Config.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}inc/\+Cache.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}inc/\+Utils.\+h\char`\"{}}\\*
\subsection*{Funzioni}
\begin{DoxyCompactItemize}
\item 
char $\ast$ \hyperlink{Client_2Cache_8c_a73ab89ae79c4dad7bd15bd0d3367be07}{get\+Filename} (char $\ast$basename)
\begin{DoxyCompactList}\small\item\em Ritorna il nome del file. \end{DoxyCompactList}\item 
F\+I\+L\+E $\ast$ \hyperlink{Client_2Cache_8c_a3bc523df2fea20d9f4d25f2596a66a71}{create\+Temp\+File} (char $\ast$basename)
\begin{DoxyCompactList}\small\item\em Funzione che crea un file temporaneo, e ritorna un puntatore ad esso. \end{DoxyCompactList}\item 
int \hyperlink{Client_2Cache_8c_ae530ba131c65658674dd0d0b3fb2ea7c}{read\+Request} (\hyperlink{structMyDFSId}{My\+D\+F\+S\+Id} $\ast$id, long pos, unsigned int size, \hyperlink{structCacheRequest}{Cache\+Request} $\ast$req)
\begin{DoxyCompactList}\small\item\em Usato per dire se il dato che voglio leggere si trova in cache oppure no. \end{DoxyCompactList}\item 
int \hyperlink{Client_2Cache_8c_a686e517ab500f68c40c03bfbc3e2e2fd}{write\+Cache} (\hyperlink{structMyDFSId}{My\+D\+F\+S\+Id} $\ast$id, void $\ast$buffer, int size, int pos)
\begin{DoxyCompactList}\small\item\em Funzione che scrive nel file di cache il contenuto di una read, senza sovrascrivere le parti scritte da write locali. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Documentazione delle funzioni}
\hypertarget{Client_2Cache_8c_a3bc523df2fea20d9f4d25f2596a66a71}{\index{Client/\+Cache.\+c@{Client/\+Cache.\+c}!create\+Temp\+File@{create\+Temp\+File}}
\index{create\+Temp\+File@{create\+Temp\+File}!Client/\+Cache.\+c@{Client/\+Cache.\+c}}
\subsubsection[{create\+Temp\+File}]{\setlength{\rightskip}{0pt plus 5cm}F\+I\+L\+E $\ast$ create\+Temp\+File (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{basename}
\end{DoxyParamCaption}
)}}\label{Client_2Cache_8c_a3bc523df2fea20d9f4d25f2596a66a71}


Funzione che crea un file temporaneo, e ritorna un puntatore ad esso. 



Referenziato da main(), e mydfs\+\_\+open().

\hypertarget{Client_2Cache_8c_a73ab89ae79c4dad7bd15bd0d3367be07}{\index{Client/\+Cache.\+c@{Client/\+Cache.\+c}!get\+Filename@{get\+Filename}}
\index{get\+Filename@{get\+Filename}!Client/\+Cache.\+c@{Client/\+Cache.\+c}}
\subsubsection[{get\+Filename}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ get\+Filename (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{basename}
\end{DoxyParamCaption}
)}}\label{Client_2Cache_8c_a73ab89ae79c4dad7bd15bd0d3367be07}


Ritorna il nome del file. 



Referenziato da create\+Temp\+File().

\hypertarget{Client_2Cache_8c_ae530ba131c65658674dd0d0b3fb2ea7c}{\index{Client/\+Cache.\+c@{Client/\+Cache.\+c}!read\+Request@{read\+Request}}
\index{read\+Request@{read\+Request}!Client/\+Cache.\+c@{Client/\+Cache.\+c}}
\subsubsection[{read\+Request}]{\setlength{\rightskip}{0pt plus 5cm}int read\+Request (
\begin{DoxyParamCaption}
\item[{{\bf My\+D\+F\+S\+Id} $\ast$}]{id, }
\item[{long}]{pos, }
\item[{unsigned int}]{size, }
\item[{{\bf Cache\+Request} $\ast$}]{req}
\end{DoxyParamCaption}
)}}\label{Client_2Cache_8c_ae530ba131c65658674dd0d0b3fb2ea7c}


Usato per dire se il dato che voglio leggere si trova in cache oppure no. 

\begin{DoxyReturn}{Restituisce}
1 M\+I\+S\+S\+: In caso di M\+I\+S\+S, dentro a req verranno messi posizione e size del dato da scaricare. 

0 H\+I\+T\+: torna false.
\end{DoxyReturn}
Nota\+: La miss si riferisce ad un \char`\"{}buco\char`\"{}, quindi bisogna chiamare la funzione piu' volte per assicurarsi che non ci siano altri miss. Nota2\+: Il lock e' in teoria troppo grande. In pratica pero', se fra la prima operazione di lettura e la seconda ci fosse una invalidazione della cache qualcosa di orrendo potrebbe accadere. Quindi va bene cosi'. 

Referenzia My\+D\+F\+S\+Id\+::filesize, Write\+Op\+::next, Read\+Op\+::next, Write\+Op\+::pos, Read\+Op\+::pos, Cache\+Request\+::pos, My\+D\+F\+S\+Id\+::read\+List\+Mutex, read\+Request(), Write\+Op\+::size, Read\+Op\+::size, e Cache\+Request\+::size.



Referenziato da mydfs\+\_\+read(), e read\+Request().

\hypertarget{Client_2Cache_8c_a686e517ab500f68c40c03bfbc3e2e2fd}{\index{Client/\+Cache.\+c@{Client/\+Cache.\+c}!write\+Cache@{write\+Cache}}
\index{write\+Cache@{write\+Cache}!Client/\+Cache.\+c@{Client/\+Cache.\+c}}
\subsubsection[{write\+Cache}]{\setlength{\rightskip}{0pt plus 5cm}int write\+Cache (
\begin{DoxyParamCaption}
\item[{{\bf My\+D\+F\+S\+Id} $\ast$}]{id, }
\item[{void $\ast$}]{buffer, }
\item[{int}]{size, }
\item[{int}]{pos}
\end{DoxyParamCaption}
)}}\label{Client_2Cache_8c_a686e517ab500f68c40c03bfbc3e2e2fd}


Funzione che scrive nel file di cache il contenuto di una read, senza sovrascrivere le parti scritte da write locali. 

Eseguo un ciclo che vede se il punto in cui\+:
\begin{DoxyEnumerate}
\item Controllo se il punto in cui voglio scrivere e' contenuto in una operazione di write. In quel caso, richiamo questa funzione spostando avanti il puntatore del buffer
\item Il punto in cui voglio scrivere non e' incluso in nessuna write. In questo caso, vedo se c'e' una write inclusa nello spazio del buffer della read che voglio scrivere. Se e' cosi', scrivo quanto posso, e se posso scrivere altro dopo la sezione di write, richiamo questa funzione ricorsivamente aggiornado gli indici.
\end{DoxyEnumerate}

Utilizzo pos, e vedo se e' contenuto in una write. Se si lo sposto fino alla fine della write, e richiamo questa funzione ricorsivamente. Raggiunto il caso base, cerco se c'e' una write contenuta fra pos e pos+size. Se e' cos√¨ mi trovo la fine della write. Eseguo la scrittura e richiamo questa funzione ricorsivamente

\begin{DoxyReturn}{Restituisce}
1 se tutto e' ok, 0 se qualcosa e' andata storta 
\end{DoxyReturn}


Referenzia My\+D\+F\+S\+Id\+::fp, log\+M(), Write\+Op\+::next, Write\+Op\+::pos, Write\+Op\+::size, e write\+Cache().



Referenziato da read\+From(), e write\+Cache().

